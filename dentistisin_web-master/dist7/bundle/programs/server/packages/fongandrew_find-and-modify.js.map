{"version":3,"sources":["fongandrew:find-and-modify/find_and_modify.js"],"names":[],"mappings":";;;;;;;;;;;;;;;AAAA,a;AACA,e;AACA,mE;;AAEA,8C;AACA,uC;AACA,yB;AACA,mC;AACA,4E;;AAEA,a;AACA,oE;;AAEA,mB;AACA,qE;;AAEA,oC;AACA,iC;AACA,2E;AACA,I;;AAEA,wB;AACA,8D;AACA,2B;;AAEA,iB;AACA,iC;AACA,+B;AACA,sB;AACA,+B;;AAEA,qB;AACA,iC;AACA,iC;AACA,oC;AACA,uC;AACA,oC;AACA,uC;AACA,oC;AACA,uC;;AAEA,gF;AACA,6B;AACA,kC;AACA,4D;AACA,+E;AACA,Q;;AAEA,6D;AACA,+C;;AAEA,sE;AACA,wD;AACA,yB;AACA,gB;AACA,e;AACA,iB;AACA,iB;AACA,Q;AACA,M;AACA,G;;AAEA,wB;AACA,+D;AACA,2B;;AAEA,2B;AACA,kC;AACA,qC;AACA,oC;AACA,yC;AACA,kC;AACA,qC;;AAEA,sD;AACA,wB;AACA,6C;AACA,O;;AAEA,Y;AACA,kC;AACA,iE;AACA,iD;AACA,4E;AACA,oC;AACA,sB;AACA,sB;AACA,S;;AAEA,uB;;AAEA,2E;AACA,4E;AACA,0E;AACA,yE;AACA,iD;AACA,uD;AACA,wE;AACA,oC;AACA,+E;AACA,2E;AACA,uE;AACA,oC;AACA,kC;AACA,0C;AACA,oD;AACA,a;AACA,uC;AACA,mD;AACA,W;;AAEA,gB;AACA,qD;AACA,W;AACA,U;AACA,uB;AACA,6D;AACA,S;AACA,O;;AAEA,iB;AACA,M;AACA,G;AACA,I;AACA,K","file":"/packages/fongandrew_find-and-modify.js","sourcesContent":["(function() {\n  'use strict';\n  // Code adapted from https://github.com/meteor/meteor/issues/1070\n\n  // Helper func to run shared validation code\n  function validate(collection, args) {\n    if(!collection._name)\n        throw new Meteor.Error(405,\n                               \"findAndModify: Must have collection name.\");\n\n    if(!args)\n      throw new Meteor.Error(405, \"findAndModify: Must have args.\");\n\n    if(!args.query)\n      throw new Meteor.Error(405, \"findAndModify: Must have query.\");\n\n    if(!args.update && !args.remove)\n      throw new Meteor.Error(405,\n                             \"findAndModify: Must have update or remove.\");\n  };\n\n  if (Meteor.isServer) {\n    Mongo.Collection.prototype.findAndModify = function(args){\n      validate(this, args);\n\n      var q = {};\n      q.query = args.query || {};\n      q.sort = args.sort || {};\n      if (args.update)\n        q.update = args.update;\n\n      q.options = {};\n      if (args.new !== undefined)\n        q.options.new = args.new;\n      if (args.remove !== undefined)\n        q.options.remove = args.remove;\n      if (args.upsert !== undefined)\n        q.options.upsert = args.upsert;\n      if (args.fields !== undefined)\n        q.options.fields = args.fields;\n\n      // If upsert, assign a string Id to $setOnInsert unless otherwise provided\n      if (q.options.upsert) {\n        q.update = q.update || {};\n        q.update.$setOnInsert = q.update.$setOnInsert || {};\n        q.update.$setOnInsert._id = q.update.$setOnInsert._id || Random.id(17);\n      } \n\n      // Use rawCollection object introduced in Meteor 1.0.4.\n      var collectionObj = this.rawCollection();\n\n      var wrappedFunc = Meteor.wrapAsync(collectionObj.findAndModify, \n                                         collectionObj);\n      return wrappedFunc(\n        q.query,\n        q.sort,\n        q.update,\n        q.options\n      );\n    };\n  }\n\n  if (Meteor.isClient) {\n    Mongo.Collection.prototype.findAndModify = function(args) {\n      validate(this, args);\n\n      var findOptions = {};\n      if (args.sort !== undefined)\n        findOptions.sort = args.sort;\n      if (args.fields !== undefined)\n        findOptions.fields = args.fields;\n      if (args.skip !== undefined)\n        findOptions.skip = args.skip;\n\n      var ret = this.findOne(args.query, findOptions);\n      if (args.remove) {\n        if (ret) this.remove({_id: ret._id});\n      }\n\n      else {\n        if (args.upsert && !ret) {\n          var writeResult = this.upsert(args.query, args.update);\n          if (writeResult.insertedId && args.new)\n            return this.findOne({_id: writeResult.insertedId}, findOptions);\n          else if (findOptions.sort)\n            return {};\n          return null;\n        }\n\n        else if (ret) {\n\n          // If we're in a simulation, it's safe to call update with normal\n          // selectors (which is needed, e.g., for modifiers with positional\n          // operators). Otherwise, we'll have to do an _id only update to\n          // get around the restriction that lets untrusted (e.g. client)\n          // code update collections by _id only.\n          var enclosing = DDP._CurrentInvocation.get();\n          var alreadyInSimulation = enclosing && enclosing.isSimulation;\n          if (alreadyInSimulation) {\n            // Add _id to query because Meteor's update doesn't include certain\n            // options that the full findAndModify does (like sort). Create\n            // shallow copy before update so as not to mess with user's\n            // original query object\n            var updatedQuery = {};\n            for (var prop in args.query) {\n              updatedQuery[prop] = args.query[prop];\n            }\n            updatedQuery._id = ret._id;\n            this.update(updatedQuery, args.update);\n          }\n\n          else {\n            this.update({_id: ret._id}, args.update);\n          }\n          \n          if (args.new)\n            return this.findOne({_id: ret._id}, findOptions);\n        }\n      }\n\n      return ret;\n    };\n  }\n    \n})();\n\n\n"]}