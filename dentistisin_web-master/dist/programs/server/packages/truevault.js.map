{"version":3,"sources":["truevault/truevault.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,4C;AACA,e;;AAEA,8C;;AAEA,c;AACA,e;AACA,oB;AACA,sB;AACA,iB;AACA,iB;AACA,e;AACA,E;;AAEA,oB;AACA,uB;AACA,2B;AACA,iB;AACA,gB;AACA,E;;AAEA,uC;AACA,iE;AACA,gF;AACA,sF;AACA,uE;AACA,uE;AACA,oE;AACA,E;;AAEA,qI;AACA,4C;;AAEA,2C;AACA,Y;AACA,M;AACA,uG;AACA,c;AACA,a;AACA,oB;AACA,Y;AACA,E;AACA,E;AACA,sC;AACA,E;;AAEA,kC;AACA,mD;AACA,4C;AACA,qC;AACA,2B;AACA,4C;AACA,uC;AACA,U;AACA,qB;AACA,iB;AACA,I;AACA,K;AACA,S;AACA,wB;AACA,E;AACA,e;AACA,E;;AAEA,mD;AACA,mB;AACA,M;AACA,2B;AACA,4C;AACA,8H;AACA,c;AACA,a;AACA,oB;AACA,Y;AACA,E;AACA,E;AACA,S;AACA,iC;AACA,0B;AACA,qC;AACA,G;AACA,E;AACA,E;AACA,6E;AACA,wE;AACA,G;AACA,4D;AACA,W;AACA,qC;AACA,8B;AACA,Y;AACA,M;AACA,4G;AACA,+E;AACA,c;AACA,a;AACA,oB;AACA,Y;AACA,E;AACA,E;AACA,e;AACA,E;;AAEA,6E;AACA,W;AACA,qC;AACA,8B;AACA,oB;AACA,Y;AACA,M;AACA,iJ;AACA,+B;AACA,c;AACA,a;AACA,oB;AACA,Y;AACA,E;AACA,E;AACA,8C;AACA,iC;AACA,2F;AACA,G;AACA,iC;AACA,2F;AACA,G;AACA,I;AACA,S;AACA,iB;AACA,iB;AACA,gC;AACA,G;AACA,E;;AAEA,4C;AACA,Y;AACA,M;AACA,2G;AACA,c;AACA,a;AACA,oB;AACA,Y;;AAEA,E;AACA,iC;AACA,E;;AAEA,0D;AACA,Y;AACA,M;AACA,mK;AACA,c;AACA,a;AACA,oB;AACA,Y;AACA,E;AACA,E;AACA,E","file":"/packages/truevault.js","sourcesContent":["// TODO Change to dealing with TrueVaultRefs\nTrueVault = {};\n\nvar endpoint = 'https://api.truevault.com/v1';\n\nvar config = {\n\tvaultId: null,\n\tkioskGroupId: null,\n\tdentistGroupId: null,\n\ttaGroupId: null,\n\tmaGroupId: null,\n\tadminKey: null\n};\n\nTrueVault.groups = {\n\tKIOSK: 'kioskGroupId',\n\tDENTIST: 'dentistGroupId',\n\tTA: 'taGroupId',\n\tMA: 'maGroupId'\n};\n\nTrueVault.config = function (options) {\n\tif (_.has(options, 'vaultId')) config.vaultId = options.vaultId;\n\tif (_.has(options, 'kioskGroupId')) config.kioskGroupId = options.kioskGroupId;\n\tif (_.has(options, 'dentistGroupId')) config.dentistGroupId = options.dentistGroupId;\n\tif (_.has(options, 'taGroupId')) config.taGroupId = options.taGroupId;\n\tif (_.has(options, 'maGroupId')) config.maGroupId = options.maGroupId;\n\tif (_.has(options, 'adminKey')) config.adminKey = options.adminKey;\n};\n\n// Simply stores truevault user_id, access_token, and expires (+20 hours) in memory rather than fetching a new token for each request\nvar tokenCache = new Mongo.Collection(null);\n\nvar getTokenTrueVault = function (userId) {\n\tvar result;\n\ttry {\n\t\tresult = HTTP.post(endpoint + '/users/' + userId + '/access_token', { auth: config.adminKey + ':' });\n\t} catch (e) {\n\t\tresult = e;\n\t\tthrow new Error();\n\t} finally {\n\t\t\n\t}\n\treturn result.data.user.access_token;\n};\n\nvar getToken = function (userId) {\n\tvar result = tokenCache.findOne({userId: userId});\n\tif (!result || new Date > result.expires) {\n\t\tresult = getTokenTrueVault(userId);\n\t\tvar expires = new Date();\n\t\texpires.setHours(expires.getHours() + 20);\n\t\ttokenCache.upsert({userId: userId}, {\n\t\t\t$set: {\n\t\t\t\texpires: expires,\n\t\t\t\ttoken: result\n\t\t\t}\n\t\t});\n\t} else {\n\t\tresult = result.token;\n\t}\n\treturn result;\n};\n\nTrueVault.createDocument = function (doc, userId) {\n\tvar token, result;\n\ttry {\n\t\ttoken = getToken(userId);\n\t\tdoc = Base64.encode(EJSON.stringify(doc));\n\t\tresult = HTTP.post(endpoint + '/vaults/' + config.vaultId + '/documents', { params: { document: doc }, auth: token + ':' });\n\t} catch (e) {\n\t\tresult = e;\n\t\tthrow new Error();\n\t} finally {\n\t\t\n\t}\n\treturn {\n\t\tdocId: result.data.document_id,\n\t\tvaultId: config.vaultId,\n\t\ttransId: result.data.transaction_id\n\t};\n};\n/*\n * At some point this should be overlaoded to accept a vaultId and a docId or\n * a vaultId and an array of docIds or an array of vaultId + docId pairs\n */\nTrueVault.readDocument = function (vaultId, docId, userId) {\n\tvar token;\n\tif(userId) token = getToken(userId);\n\telse token = config.adminKey;\n\tvar result;\n\ttry {\n\t\tresult = HTTP.get(endpoint + '/vaults/' + vaultId + '/documents/' + docId, { auth: token + ':' }).content;\n\t\tresult = EJSON.parse(String.fromCharCode.apply(null, Base64.decode(result)));\n\t} catch (e) {\n\t\tresult = e;\n\t\tthrow new Error();\n\t} finally {\n\t\t\n\t}\n\treturn result;\n};\n\nTrueVault.readTwoDocuments = function (vaultId, docIdOne, docIdTwo, userId) {\n\tvar token;\n\tif(userId) token = getToken(userId);\n\telse token = config.adminKey;\n\tvar docOne, docTwo;\n\tvar result;\n\ttry {\n\t\tresult = HTTP.get('https://api.truevault.com/v1/vaults/' + vaultId + '/documents/' + docIdOne + ',' + docIdTwo, { auth: token + ':' }).content;\n\t\tresult = EJSON.parse(result);\n\t} catch (e) {\n\t\tresult = e;\n\t\tthrow new Error();\n\t} finally {\n\t\t\n\t}\n\t_.each(result.documents, function(document) {\n\t\tif (document.id === docIdOne) {\n\t\t\tdocOne = EJSON.parse(String.fromCharCode.apply(null, Base64.decode(document.document)));\n\t\t}\n\t\tif (document.id === docIdTwo) {\n\t\t\tdocTwo = EJSON.parse(String.fromCharCode.apply(null, Base64.decode(document.document)));\n\t\t}\n\t});\n\treturn {\n\t\tdocOne: docOne,\n\t\tdocTwo: docTwo,\n\t\ttransId: result.transaction_id\n\t};\n};\n\nTrueVault.createUser = function (username) {\n\tvar result;\n\ttry {\n\t\tresult = HTTP.post(endpoint + '/users', { params: { username: username }, auth: config.adminKey + ':' });\n\t} catch (e) {\n\t\tresult = e;\n\t\tthrow new Error();\n\t} finally {\n\n\t}\n\treturn result.data.user.user_id;\n};\n\nTrueVault.updateGroup = function (group, userId, remove) {\n\tvar result;\n\ttry {\n\t\tresult = HTTP.put(endpoint + '/groups/' + config[group], { params: { user_ids: userId, operation: remove ? 'REMOVE' : 'APPEND' }, auth: config.adminKey + ':' });\n\t} catch (e) {\n\t\tresult = e;\n\t\tthrow new Error();\n\t} finally {\n\t\t\n\t}\n};\n"]}